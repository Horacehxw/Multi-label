<html lang="en">
<head>
<title>Pycodes Documentation</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name=description content="Pycodes Documentation">
<meta name=generator content="makeinfo 4.2">
<link href="http://www.gnu.org/software/texinfo/" rel=generator-home>
</head>
<body>
<h1>Pycodes Documentation</h1>

<h2>Table of Contents</h2>
<ul>
<li><a name="toc_Overview"></a>
    <a href="#Overview">Overview</a>
<li><a name="toc_Installation%20and%20Configuration"></a>
    <a href="#Installation%20and%20Configuration">Installing</a>
<ul>
<li><a href="#Installation%20and%20Configuration">Prerequisites</a>
<li><a href="#Installation%20and%20Configuration">Installing</a>
</ul>
<li><a name="toc_The%20pyLDPC%20Package"></a>
    <a href="#The%20pyLDPC%20Package">The pyLDPC Package</a>
<ul>
<li><a href="#Quantization">Quantization</a>
<ul>
<li><a href="#Quantization">Binary Erasure Quantization Example</a>
<li><a href="#Quantization">Binary Symmetric Quantization Example</a>
</ul>
<li><a href="#Channel%20Coding">Channel Coding</a>
<ul>
<li><a href="#Channel%20Coding">Binary Erasure Channel Example</a>
<li><a href="#Channel%20Coding">Binary Symmetric Channel Example</a>
</ul>
<li><a href="#Extending%20pyLDPC">Extending pyLDPC</a>
</ul>
<li><a name="toc_The%20utils%20package"></a>
    <a href="#The%20utils%20package">The utils package</a>
<ul>
<li><a href="#CodeMaker.py">CodeMaker.py</a>
<li><a href="#FormLP.py">FormLP.py</a>
<ul>
<li><a href="#FormLP.py">Using ECCLPFormer For LP Decoding of Error Correction Codes</a>
<li><a href="#FormLP.py">Using QuantLPFormer For Quanization</a>
</ul>
<li><a href="#visualize.py">visualize.py</a>
</ul>
<li><a name="toc_LICENSE"></a>
    <a href="#LICENSE">LICENSE</a>
<li><a name="toc_Concept%20Index"></a>
    <a href="#Concept%20Index">Concept Index</a>
</ul>


<p><hr>
Node:<a name="Top">Top</a>,
Next:<a rel=next accesskey=n href="#Overview">Overview</a>,
Previous:<a rel=previous accesskey=p href="#dir">(dir)</a>,
Up:<a rel=up accesskey=u href="#dir">(dir)</a>
<br>

<ul>
<li><a accesskey=1 href="#Overview">Overview</a>: 
<li><a accesskey=2 href="#Installation%20and%20Configuration">Installation and Configuration</a>: 
<li><a accesskey=3 href="#The%20pyLDPC%20Package">The pyLDPC Package</a>: 
<li><a accesskey=4 href="#The%20utils%20package">The utils package</a>: 
<li><a accesskey=5 href="#Concept%20Index">Concept Index</a>: 
<li><a accesskey=6 href="#LICENSE">LICENSE</a>: 
</ul>

<p><hr>
Node:<a name="Overview">Overview</a>,
Next:<a rel=next accesskey=n href="#Installation%20and%20Configuration">Installation and Configuration</a>,
Previous:<a rel=previous accesskey=p href="#Top">Top</a>,
Up:<a rel=up accesskey=u href="#Top">Top</a>
<br>

<h2>Overview</h2>

<p>The pycodes package provides various extensions to Python which are
useful in developing and analyzing error correcting codes and data
compression codes (especially low density parity check codes).  The
code was originally developed by Emin Martinian; questions and
comments should be directed to him via <a href="mailto:emin@alum.mit.edu">emin@alum.mit.edu</a> or
<a href="mailto:emin63@alum.berkeley.edu">emin63@alum.berkeley.edu</a>.  For copying, modificiation, and
distribution information, see the <a href="#LICENSE">LICENSE</a>.

<p>The following modules are provided:
<dl>

<br><dt><code>pyLDPC</code>
<dd>Provides the main routines (which are implemented in C) as python commands.

<br><dt><code>utils</code>
<dd>Provides utilities such as channels, encoders, routines to translate
things into linear programming relaxations, etc.

<br><dt><code>tests</code>
<dd>Provides automated tests both to analyze/evaluate codes and decoding
algorithms as well as to make sure everything is working correctly. 
One simple way to run a given test is by importing the appropriate
file into python.  For example, the following commands executed in the
directory containing the pycodes directory would run a small BEC
quantization test:

<br><pre>$ echo from pycodes.tests.quantization.BEC import small_BEC_perf | python
</pre>

<p>Similarly, you can run other tests in the directories
<code>pycodes/tests/quantization/BEC</code>,
<code>pycodes/tests/channel_coding/BSC</code>, etc. by using a command like
the one above.

</dl>

<p><hr>
Node:<a name="Installation%20and%20Configuration">Installation and Configuration</a>,
Next:<a rel=next accesskey=n href="#The%20pyLDPC%20Package">The pyLDPC Package</a>,
Previous:<a rel=previous accesskey=p href="#Overview">Overview</a>,
Up:<a rel=up accesskey=u href="#Top">Top</a>
<br>

<h2>Installing</h2>

<p>The pycodes package provides various extensions to Python
which are useful in developing and analyzing error correcting
codes and data compression codes.

<h3>Prerequisites</h3>

<p>You will need the following installed on your system to use all
of the pycodes features:

<ul>

<li>Python (preferably version 2.2 or later) (<a href="http://www.python.org">http://www.python.org</a>)

<li>biggles (optional; only required if you want plotting) (<a href="http://biggles.sourceforge.net">http://biggles.sourceforge.net</a>)

<li>GLPK (optinal; only required if you want to do LP relaxations) (<a href="http://www.gnu.org/software/glpk/glpk.html">http://www.gnu.org/software/glpk/glpk.html</a>)

</ul>

<h3>Installing</h3>

<p>The following procedure is required to use the main iterative coding
and decoding routines.  If you just want to use things in the utils
directory, you do not need to compile anything.

<p>Edit the file setup.py to edit installation options (e.g., if you want
to compile in debug mode or optimization mode.  Then, in this
directory, execute the command

<br><pre>$ python setup.py install
</pre>

<p>to compile the required python extensions and install them globally.

<p>After the installation completes, you can use pycodes just like
any other python module.  For example, to run the regression tests
you could start python and do

<br><pre>&gt;&gt;&gt; import pycodes, pycodes.tests
&gt;&gt;&gt; pycodes.tests.DoRegressionTests()
</pre>

<p>If you don't want to globally install pycodes, you can just compile
it in place and use it as a local python module.  To do this,
uncomment the lines for [build_ext] in setup.cfg and do

<br><pre>$ python setup.py build
</pre>

<p>to compile everything.  Make sure that the name of the directory
containing the pycodes module is named <code>pycodes</code> and not
something like <code>pycodes-1.0</code>.  To use pycodes, start python in
the directory containing the <code>pycodes</code> directory.  For example,
to run the regression tests you could do

<br><pre>$ python
&gt;&gt;&gt; import pycodes, pycodes.tests
&gt;&gt;&gt; pycodes.tests.DoRegressionTests()
</pre>

<p><hr>
Node:<a name="The%20pyLDPC%20Package">The pyLDPC Package</a>,
Next:<a rel=next accesskey=n href="#The%20utils%20package">The utils package</a>,
Previous:<a rel=previous accesskey=p href="#Installation%20and%20Configuration">Installation and Configuration</a>,
Up:<a rel=up accesskey=u href="#Top">Top</a>
<br>

<h2>The pyLDPC Package</h2>

<p>The pyLDPC package provides low density parity check (LDPC) codes and
their dual codes which are low density generator matrix (LDGM) codes. 
To create a new LDPC or LDGM code you can use the <code>LDPCCode</code> or
<code>DualLDPCCode</code> commands to create a new code.  The
<code>setevidence</code> command sets the channel evidence and specifies the
decoding algorithm to use, while the <code>decode</code> command runs an
iteration of decoding.  The <code>getbeliefs</code> command returns the
computed beliefs.

<ul>
<li><a accesskey=1 href="#Quantization">Quantization</a>: 
<li><a accesskey=2 href="#Channel%20Coding">Channel Coding</a>: 
<li><a accesskey=3 href="#Extending%20pyLDPC">Extending pyLDPC</a>: 
</ul>

<p><hr>
Node:<a name="Quantization">Quantization</a>,
Next:<a rel=next accesskey=n href="#Channel%20Coding">Channel Coding</a>,
Previous:<a rel=previous accesskey=p href="#The%20pyLDPC%20Package">The pyLDPC Package</a>,
Up:<a rel=up accesskey=u href="#The%20pyLDPC%20Package">The pyLDPC Package</a>
<br>

<h3>Quantization</h3>

<h4>Binary Erasure Quantization Example</h4>

<p>The following sequence of python commands creates the dual of a
Hamming code, sets the evidence to correspond to the bits
<code>[0,1,?,1,?,?,?]</code>, decodes by finding a codeword to match the
unerased bits, and prints out the result:

<br><pre>&gt;&gt;&gt; from pycodes.pyLDPC import DualLDPCCode
&gt;&gt;&gt; code = DualLDPCCode(7,4,12,[[0,1,2,4],[1,2,3,5],[2,3,4,6]])
&gt;&gt;&gt; code.setevidence(ev=[1,-1,0,-1,0,0,0],alg='BECQuant')
&gt;&gt;&gt; code.decode()
&gt;&gt;&gt; beliefs = code.getbeliefs()
&gt;&gt;&gt; print beliefs[0:3] # first K beliefs are for hidden vars
[1.0, -1.0, 1.0]
</pre>

<p>Note that the beliefs are in something like log-likelihood-ratio
format.  To map the beliefs into zeros and ones you can do

<br><pre>&gt;&gt;&gt; comp = map(lambda x: x &lt; 0,beliefs[0:3])
&gt;&gt;&gt; print comp
[0, 1, 0]
</pre>

<p>In order to see what codeword is produced from the compressed
result, you can use the EncodeFromLinkArray utility as follows:

<br><pre>&gt;&gt;&gt; from pycodes.utils.encoders import EncodeFromLinkArray
&gt;&gt;&gt; r = EncodeFromLinkArray(comp,7,[[0,1,2,4],[1,2,3,5],[2,3,4,6]])
&gt;&gt;&gt; print r
[0, 1, 1, 1, 0, 1, 0]
</pre>

<p>Note that the first, second, and fourth positions of the codeword
match the source.

<h4>Binary Symmetric Quantization Example</h4>

<p>The following sequence of python commands creates the dual of a
length 3000 (3,6) Gallager code, sets the evidence to be a random
binary word, quantizes the result using the AccBitFlip algorithm,
and counts the percentage of distorted bits:

<br><pre>&gt;&gt;&gt; from pycodes.utils.CodeMaker import make_H_gallager
&gt;&gt;&gt; from pycodes.utils.channels import GetRandomBinaryCodeword
&gt;&gt;&gt; L = make_H_gallager(3000,3,6) # make the code
&gt;&gt;&gt; E = reduce(lambda x,y:x+y,map(lambda z:len(z),L))#count edges in code
&gt;&gt;&gt; code = DualLDPCCode(3000,1500,E,L)
&gt;&gt;&gt; source = GetRandomBinaryCodeword(3000)
&gt;&gt;&gt; ev = map(lambda b: 1 - 2*b,source) # map bits to log-likelihoods
&gt;&gt;&gt; code.setevidence(ev,alg='AccBitFlip')
&gt;&gt;&gt; for iteration in range(25):
...    code.decode()
&gt;&gt;&gt; beliefs = code.getbeliefs()[0:1500]
&gt;&gt;&gt; comp = map(lambda x: x &lt; 0,beliefs) # map log-likelihoods to bits
&gt;&gt;&gt; result = EncodeFromLinkArray(comp,3000,L)
&gt;&gt;&gt; diffs = reduce(lambda x,y:x+y,map(lambda r,s: r!=s,result,source))
&gt;&gt;&gt; print (diffs/3000.0 &gt; 0.14 and diffs/3000.0 &lt; .17)
1
&gt;&gt;&gt; # the above insures that the number of diffs is reasonable.
</pre>

<p><hr>
Node:<a name="Channel%20Coding">Channel Coding</a>,
Next:<a rel=next accesskey=n href="#Extending%20pyLDPC">Extending pyLDPC</a>,
Previous:<a rel=previous accesskey=p href="#Quantization">Quantization</a>,
Up:<a rel=up accesskey=u href="#The%20pyLDPC%20Package">The pyLDPC Package</a>
<br>

<h3>Channel Coding</h3>

<h4>Binary Erasure Channel Example</h4>

<br><pre>&gt;&gt;&gt; from pycodes.pyLDPC import LDPCCode
&gt;&gt;&gt; code = LDPCCode(7,4,12,[[0,1,2,4],[1,2,3,5],[2,3,4,6]])
&gt;&gt;&gt; # Set the channel evidence to the all-zeros codeword with 2 erasures
&gt;&gt;&gt; code.setevidence(ev=[1,1,0,0,1,1,1],alg='SumProductBP')
&gt;&gt;&gt; for iteration in range(25):
...    code.decode()
&gt;&gt;&gt; beliefs = code.getbeliefs()
&gt;&gt;&gt; codeword = map(lambda x: x &gt; 0.5,beliefs)
&gt;&gt;&gt; print codeword
[0, 0, 0, 0, 0, 0, 0]
</pre>

<h4>Binary Symmetric Channel Example</h4>

<br><pre>&gt;&gt;&gt; from pycodes.pyLDPC import LDPCCode
&gt;&gt;&gt; from pycodes.utils.CodeMaker import make_H_gallager
&gt;&gt;&gt; from pycodes.utils.channels import BSC
&gt;&gt;&gt; L = make_H_gallager(3000,3,6) # make the code
&gt;&gt;&gt; E = reduce(lambda x,y:x+y,map(lambda z:len(z),L))#count edges in code
&gt;&gt;&gt; code = LDPCCode(3000,1500,E,L)
&gt;&gt;&gt; # Set the channel evidence to the all-zeros codeword through a BSC
&gt;&gt;&gt; ev = BSC([0]*3000,0.05)
&gt;&gt;&gt; code.setevidence(ev,alg='SumProductBP')
&gt;&gt;&gt; for iteration in range(25):
...    code.decode()
&gt;&gt;&gt; beliefs = code.getbeliefs()
&gt;&gt;&gt; result = map(lambda x: x &gt; 0.5,beliefs)
&gt;&gt;&gt; print 'num decoding errors = ' + `reduce(lambda a,b:a+b,result)`
num decoding errors = 0
</pre>

<p><hr>
Node:<a name="Extending%20pyLDPC">Extending pyLDPC</a>,
Previous:<a rel=previous accesskey=p href="#Channel%20Coding">Channel Coding</a>,
Up:<a rel=up accesskey=u href="#The%20pyLDPC%20Package">The pyLDPC Package</a>
<br>

<h3>Extending pyLDPC</h3>

<p>You can easily extend the pyLDPC package by adding additional decoding
algorithms for channel coding or quantization.  To add a new decoding
algorithm for the LDPCCode or DualLDPCCode object, you need to do the
following:

<ol type=1 start=1>
</p><li>Define a new instance of the <code>CodeGraphAlgorithm</code> or
<code>DualCodeGraphAlgorithm</code> data structure.

<li>Add the new algorithm to the <code>CodeGraphAlgorithms</code> or
<code>DualCodeGraphAlgorithms</code> data
structure in <code>c_src/pyLDPC/CodeGraphAlgorithms.c</code> or
<code>c_src/pyLDPC/CodeGraphAlgorithms.c</code>.

<li>Add the
name of the algorithm to the <code>CodeGraphAlgorithmNames</code> or
<code>DualCodeGraphAlgorithmNames</code> array in
<code>c_src/pyLDPC/CodeGraphAlgorithms.c</code> or
<code>c_src/pyLDPC/DualCodeGraphAlgorithms.c</code>.

</ol>

<p>The <code>CodeGraphAlgorithm</code> and <code>DualCodeGraphAlgorithm</code> data
structure defined in
<code>c_src/pyLDPC/CodeGraphAlgorithms.h</code> and
<code>c_src/pyLDPC/DualCodeGraphAlgorithms.h</code> have a field for the
algorithm name, a <code>clientData</code> field for storing data required by
the algorithm, fields for functions to set evidence, get beliefs,
initialize, deallocate the algorithm, do a an iteration of decoding,
and possibly other actions as well.  Once you provide these functions
and add your algorithm and its name to the appropriate arrays, you can
access it through python just like the existing algorithms.  For
example, if you created a new algorithm called <code>my_decode</code>, you
could use it by replacing the <code>code.setevidence</code> command in the
examples above with

<br><pre>&gt;&gt;&gt; code.setevidence(ev,alg='my_decode')
</pre>

<p><hr>
Node:<a name="The%20utils%20package">The utils package</a>,
Next:<a rel=next accesskey=n href="#LICENSE">LICENSE</a>,
Previous:<a rel=previous accesskey=p href="#The%20pyLDPC%20Package">The pyLDPC Package</a>,
Up:<a rel=up accesskey=u href="#Top">Top</a>
<br>

<h2>The utils package</h2>

<p>The utils package provides various utilities for creating,
visualizing, and analyzing low density codes.  You can use most of
these features even without compiling the C code in the c_src
directory.

<ul>
<li><a accesskey=1 href="#CodeMaker.py">CodeMaker.py</a>: 
<li><a accesskey=2 href="#FormLP.py">FormLP.py</a>: 
<li><a accesskey=3 href="#visualize.py">visualize.py</a>: 
</ul>

<p><hr>
Node:<a name="CodeMaker.py">CodeMaker.py</a>,
Next:<a rel=next accesskey=n href="#FormLP.py">FormLP.py</a>,
Previous:<a rel=previous accesskey=p href="#The%20utils%20package">The utils package</a>,
Up:<a rel=up accesskey=u href="#The%20utils%20package">The utils package</a>
<br>

<h3>CodeMaker.py</h3>

<p>The CodeMaker package contains function to create regular and irregular
Gallager codes.  For example, to create a 3,6 Gallager code
of block length 30 and dimension 15, you could do

<br><pre>&gt;&gt;&gt; regL = make_H_gallager(30,3,6)
</pre>

<p>To create an irregular Gallager code with 4 variables of degree 1,
4 variables of degree 2, 2 variables of degree 3, 3 checks of degree 2,
and 4 checks of degree 3, you could do

<br><pre>&gt;&gt;&gt; iregL = MakeIrregularLDPCCode(10,3,{1:4,2:4,3:2},{2:3,3:4})
</pre>

<p>To create an irregular Gallager code with degree sequences
lambda(x) = 0.33241 x^2 + 0.24632 x^3 + 0.11014 x^4 + 0.31112 x^6
rho(x) = 0.76611 x^6 + 0.23380 x^7 you could do

<br><pre>&gt;&gt;&gt; iregL = MakeIrregularLDPCCodeFromLambdaRho(30,15,{2:0.33241, 3:.24632, 4:.11014, 6:0.31112},{6:.76611, 7:.23389})
</pre>

<p>Finally, note that although it is possible to make regular
Gallager codes using the Irregular code functions,
YOU SHOULD NOT DO THAT.  The irregular code functions
only give you approximatley the degree sequence you request
due to issues with randomly adding edges and removing
redundant edges.

<p><hr>
Node:<a name="FormLP.py">FormLP.py</a>,
Next:<a rel=next accesskey=n href="#visualize.py">visualize.py</a>,
Previous:<a rel=previous accesskey=p href="#CodeMaker.py">CodeMaker.py</a>,
Up:<a rel=up accesskey=u href="#The%20utils%20package">The utils package</a>
<br>

<h3>FormLP.py</h3>

<p>This module provides the ECCLPFormer class and QuantLPFormer to
decode a low density parity check (LDPC) error correcting code or
quantize via the dual of an LDPC code using a linear programming
relaxation.  The basic idea is that you instantiate an ECCLPFormer or
QuantLPFormer and give it the code parameters.  Then you tell it to
form an LP and either solve it or print it out.

<p>Before using this file you need to download and install the freely
available GNU Linear Programming Kit (GLPK).  If you install the
executable glpsol from GLPK in a weird place that is not in the path
seen by python, set the default for the LPSolver variable in the
__init__ method of the LPFormer base class to point to the glpsol
executable.

<p>Some examples of how to use the ECCLPFormer and QuantLPFormer are shown
below.

<h4>Using ECCLPFormer For LP Decoding of Error Correction Codes</h4>

<p>The following is a simple example of how to use the ECCLPFormer class
for a parity check matrix representing the code shown below.

<br><pre>y0  y1     y2  y3
 =  =      =   =
 \  |\    /|  /
  \ | \  / | /
   \|  \/  |/
    +   +  +
</pre>

<p>The only two codewords for this code are 0000 and 1111. 
First we generat the ECCLPFormer class, then we use it solve for
the optimal y0,y1,y2,y3 given the received data [1,0,1,1]. 
This received data corresponds to sending 1111 and getting an
error on the second bit.  The LP decoder correcterly decoes
to the answer y0,y1,y2,y3 = 1,1,1,1.

<br><pre>&gt;&gt;&gt; from FormLP import *
&gt;&gt;&gt; r = ECCLPFormer(4,1,[[0,1],[1,2],[2,3]])
&gt;&gt;&gt; r.FormLP([1,0,1,1])
&gt;&gt;&gt; (v,s,o) = r.SolveLP()
&gt;&gt;&gt; print v
[1.0, 1.0, 1.0, 1.0]
</pre>

<p>Next we do LP decoding for a medium size Gallager code assuming
that the all zeros codeword was transmitted.  Feldman, Karger,
and Wainwright argue that analyzing things assuming the all-0
codeword was sent over a binary symmetric channel is valid provided
the LP satisfies certain conditions (see their 2003 CISS paper
for more details).  IMPORTANT: the all-0 assumption works for
analyzing things sent over a BSC but *NOT* over an erasure channel. 
The following test takes about a minute to run on a Mac G3.
<br><pre>&gt;&gt;&gt; N = 1200
&gt;&gt;&gt; K = 600
&gt;&gt;&gt; numErrors = 90 # error rate of 7.5%
&gt;&gt;&gt; from FormLP import *
&gt;&gt;&gt; from CodeMaker import *
&gt;&gt;&gt; from random import *
&gt;&gt;&gt; regL = make_H_gallager(N,3,6)
&gt;&gt;&gt; origSource = [0]*N
&gt;&gt;&gt; recSource = list(origSource)
&gt;&gt;&gt; i = 0
&gt;&gt;&gt; while (i &lt; numErrors):
... 	index = randrange(N)
... 	if (0 == recSource[index]):
... 	    recSource[randrange(N)] = 1
... 	    i = i+1
...
&gt;&gt;&gt; r = ECCLPFormer(N,K,regL)
&gt;&gt;&gt; r.FormLP(recSource)
&gt;&gt;&gt; (v,s,o) = r.SolveLP()
&gt;&gt;&gt; errors = map(lambda x,y: int(x) != int(y), origSource,v)
&gt;&gt;&gt; print 'num errors = ',  errors.count(1)
num errors =  0
</pre>

<h4>Using QuantLPFormer For Quanization</h4>

<p>The following is a simple example of how to use the QuantLPFormer class
for a generator matrix representing the code shown below.

<br><pre>y0  y1     y2  y3
 +  +      +   +
 \  |\    /|  /
  \ | \  / | /
   \|  \/  |/
   x0  x1  x2
</pre>

<p>First we generat the QuantLPFormer class, then we use it solve for
the optimal x0,x1,x2 when y0,y1,y2,y3=[1,0,0,1].  The answer turns
out to be x0,x1,x2 = 1,1,1.

<br><pre>&gt;&gt;&gt; from FormLP import *
&gt;&gt;&gt; r = QuantLPFormer(4,3,[[0],[0,1],[1,2],[2]])
&gt;&gt;&gt; r.FormLP([1,0,0,1])
&gt;&gt;&gt; (v,s,o) = r.SolveLP()
&gt;&gt;&gt; print v
[1.0, 1.0, 1.0]
</pre>

<p>In the following example we take the dual of a (7,4) Hamming code using the
built in function TransposeCodeMatrix and then use that as the generator
matrix for quantization.  In this example we quantize the
sequence 0,*,*,*,*,*,1 where the *'s represent don't cares which can
be reconstructed to either 0 or 1.

<br><pre>&gt;&gt;&gt; r = QuantLPFormer(7,3,TransposeCodeMatrix(7,4,[[0,1,2,4],[1,2,3,5],[2,3,4,6]]))
&gt;&gt;&gt; r.FormLP([0,.5,.5,.5,.5,.5,1])
&gt;&gt;&gt; (v,s,o) = r.SolveLP()
&gt;&gt;&gt; print v
[0.0, 0.0, 1.0]
</pre>

<p>Next we iteratively solve a quantization LP for a medium size code. 
This does not seem to work all that well, but none of the other LP
relaxations does much better at quantization either.

<br><pre>&gt;&gt;&gt; N = 300
&gt;&gt;&gt; K = 150
&gt;&gt;&gt; numErase = 180
&gt;&gt;&gt; numIter = 1000
&gt;&gt;&gt; from FormLP import *
&gt;&gt;&gt; from CodeMaker import *
&gt;&gt;&gt; from random import *
&gt;&gt;&gt; regL = make_H_gallager(N,3,6)
&gt;&gt;&gt; source = map(lambda x: round(random()),range(N))
&gt;&gt;&gt; for i in range(numErase):
... 	source[randrange(N)] = 0.5
...
&gt;&gt;&gt; r = QuantLPFormer(N,K,TransposeCodeMatrix(N,K,regL))
&gt;&gt;&gt; r.FormLP(source)
&gt;&gt;&gt; (v,s,o) = r.IterSolveLP(numIter,verbose=0)
&gt;&gt;&gt; from encoders import *
&gt;&gt;&gt; recon = EncodeFromLinkArray(map(lambda x: int(x),v),N,regL)
&gt;&gt;&gt; diffs = map(lambda x,y: x != 0.5 and x != y, source,recon)
&gt;&gt;&gt; print 'num flips = ',  diffs.count(1)
num flips =  25
&gt;&gt;&gt; if (25 != diffs.count(1)):
... 	print 'failure may be due to diffs w/glpsol on different platforms'
&gt;&gt;&gt;
</pre>

<p>The following example illustrates what can go wrong with the LP
relaxation in doing quantization.  Choosing v = [1.0,1.0,0.0] would
reconstruct the source perfectly in all the unerased positions
(places where the source is not 0.5).  But the LP relaxation produces
the vector [1.0/3.0, 1.0/3.0, 1.0/3.0].  First, this 'solution' is
not even binary, and second even rounding the bits would not give the
right answer.

<br><pre>&gt;&gt;&gt; from FormLP import *
&gt;&gt;&gt; from CodeMaker import *
&gt;&gt;&gt; from random import *
&gt;&gt;&gt; hammingCode = [[0,1,2,4],[1,2,3,5],[2,3,4,6]]
&gt;&gt;&gt; source = [0.5, 0.0, 0.0, 0.5, 1.0, 0.5, 0.5]
&gt;&gt;&gt; r = QuantLPFormer(7,3,TransposeCodeMatrix(7,4,hammingCode))
&gt;&gt;&gt; r.FormErasureLP(source)
&gt;&gt;&gt; (v,s,o) = r.SolveLP()
&gt;&gt;&gt; from encoders import *
&gt;&gt;&gt; recon = EncodeFromLinkArray(map(lambda x: int(x),v),7,hammingCode)
&gt;&gt;&gt; diffs = map(lambda x,y: x != 0.5 and x != y, source,recon)
&gt;&gt;&gt; print 'num flips = ', diffs.count(1)
num flips =  1
</pre>

<p><hr>
Node:<a name="visualize.py">visualize.py</a>,
Previous:<a rel=previous accesskey=p href="#FormLP.py">FormLP.py</a>,
Up:<a rel=up accesskey=u href="#The%20utils%20package">The utils package</a>
<br>

<h3>visualize.py</h3>

<p>The visualize package contains routines to draw a low density parity
check code graph or the dual of a low density parity check code graph. 
The main functions to call are:

<br><pre>VisualizeCodeGraph
VisualizeDualCodeGraph
</pre>

<p>For example,

<br><pre>&gt;&gt;&gt; VisualizeCodeGraph(7,4,[[0,1,2,4],[1,2,3,5],[2,3,4,6]])
</pre>

<p>will display the graph for a Hamming code, while

<br><pre>&gt;&gt;&gt; VisualizeDualCodeGraph(7,4,[[0,1,2,4],[1,2,3,5],[2,3,4,6]])
</pre>

<p>will display the graph for its dual.

<p><hr>
Node:<a name="LICENSE">LICENSE</a>,
Next:<a rel=next accesskey=n href="#Concept%20Index">Concept Index</a>,
Previous:<a rel=previous accesskey=p href="#The%20utils%20package">The utils package</a>,
Up:<a rel=up accesskey=u href="#Top">Top</a>
<br>

<h2>LICENSE</h2>

<p>Copyright 2003 Mitsubishi Electric Research Laboratories All Rights
     Reserved.  Permission to use, copy and modify this software and its
     documentation without fee for educational, research and non-profit
     purposes, is hereby granted, provided that the above copyright
     notice and the following three paragraphs appear in all copies.

<p>To request permission to incorporate this software into commercial
     products contact:  Vice President of Marketing and Business
     Development;  Mitsubishi Electric Research Laboratories (MERL), 201
     Broadway, Cambridge, MA   02139 or <a href="mailto:license@merl.com">license@merl.com</a>.

<p>IN NO EVENT SHALL MERL BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
     SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST
     PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS
     DOCUMENTATION, EVEN IF MERL HAS BEEN ADVISED OF THE POSSIBILITY OF
     SUCH DAMAGES.

<p>MERL SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT
     LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
     FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS ON AN
     "AS IS" BASIS, AND MERL HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE,
     SUPPORT, UPDATES, ENHANCEMENTS OR MODIFICATIONS.

<p><hr>
Node:<a name="Concept%20Index">Concept Index</a>,
Previous:<a rel=previous accesskey=p href="#LICENSE">LICENSE</a>,
Up:<a rel=up accesskey=u href="#Top">Top</a>
<br>

<h2>Concept Index</h2>

<ul compact>
<li>Adding new decoding algorithms: <a href="#Extending%20pyLDPC">Extending pyLDPC</a>
<li>Binary Erasure Channel: <a href="#Channel%20Coding">Channel Coding</a>
<li>Binary Erasure Quantization: <a href="#Quantization">Quantization</a>
<li>Binary Symmetric Channel: <a href="#Channel%20Coding">Channel Coding</a>
<li>Binary Symmetric Quantization: <a href="#Quantization">Quantization</a>
<li>Channel Coding: <a href="#Channel%20Coding">Channel Coding</a>
<li>CodeMaker.py: <a href="#CodeMaker.py">CodeMaker.py</a>
<li>ECCLPFormer Examples: <a href="#FormLP.py">FormLP.py</a>
<li>FormLP.py: <a href="#FormLP.py">FormLP.py</a>
<li>Installing: <a href="#Installation%20and%20Configuration">Installation and Configuration</a>
<li>Quantization: <a href="#Quantization">Quantization</a>
<li>QuantLPFormer Examples: <a href="#FormLP.py">FormLP.py</a>
<li>visualize.py: <a href="#visualize.py">visualize.py</a>
</ul>


</body></html>

